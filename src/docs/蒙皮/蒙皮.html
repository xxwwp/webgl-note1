<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>蒙皮</title>
    <link rel="stylesheet" href="../../assets/global.css" />
    <script src="../../assets/global.js" defer></script>
  </head>
  <body>
    <article class="article">
      <h1>蒙皮</h1>
      <hr />

      <p>
        本文参考
        <a href="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">《WebGL2 基础理论》 - 蒙皮</a
        >。
      </p>

      <p>
        蒙皮是对层次模型描述的升级，之前的层次模型只能解决关节变换时相关骨骼应该如何变换，而蒙皮则是解决关节变换时，皮肤上的顶点如何变化。
      </p>

      <p>
        <strong>蒙皮的概念是根据多矩阵的加权影响来移动一组顶点</strong
        >。蒙皮概念中把“骨骼”比作一个矩阵，每个骨骼肯定是有一个关节，有的骨骼被定义成只有关节没有骨头的部分。然而皮肤上的点就受到了相关骨骼加权后的影响。
      </p>

      <p>
        注意蒙皮不同于前面的层次模型，层次模型是让一个模型上所有的点都运用一个矩阵，比如大臂和小臂是两个矩阵。但是这两个矩阵各自作用了大臂和小臂上所有的点，这使得在关节处有明显的穿模情况。
      </p>

      <p>
        而蒙皮的概念则是让每个点作用不同的矩阵，并且进行加权。这就像介于两个关节之间的皮肤一定会因为这两个关节的活动变得紧致或者褶皱，也就是说两个关节处的矩阵都影响了它们之间皮肤上的顶点。这个过程还需要进行加权，以确定倒是那个骨骼对这个皮肤上的顶点影响更大。
      </p>

      <p>蒙皮和层次模型类似的一点是，末端的骨骼矩阵肯定是前端的子级，是树形结构。</p>

      <p>
        总体的结论就是，我们用矩阵来描述骨骼（或关键）的变换，皮肤上每个顶点都根据它们关联的骨骼矩阵加权来影响自身。
      </p>

      <p>
        无限制的情况下，我们可以让每个骨骼都应用到每个皮肤顶点上，那么每个皮肤顶点就要记录每个骨骼对自己影响的权重，假设
        10000 个顶点，300 个骨骼，那么权重就要记录 300
        万个，这个笛卡尔积显然不够快。并且按道理脚拇指上的骨骼活动不会作用眼睛皮上的顶点，它们相差太远了。所以经验上我们认为一个皮肤顶点最多受到
        4 个骨骼影响，即四个矩阵影响，并且还需要对它们进行加权。
      </p>

      <p>根据前面讲述的逻辑，蒙皮的算法大概是：</p>

      <pre data-code="code1.glsl" data-lang="glsl"></pre>
      <p>
        上述代码来自
        <a href="https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-skinning.html">《WebGL2 基础理论》 - 蒙皮</a>
      </p>

      <p>
        这样每个顶点就应用了它们关联的四个骨骼，并且进行了加权，因为是其次坐标系，所以权重可以是任意值大小，因为最后会进行归一化。
      </p>

      <p>
        但是这些骨骼矩阵不能简单运用的直接运用到每个顶点，因为末端的骨骼位置依赖前端骨骼的旋转，但是末端的旋转又不依赖前端骨骼的旋转。所以计算的时候要抵消这部分位移，简单的方式就是每个关节乘以位移的逆矩阵后再进行旋转。
      </p>

      <blockquote>注意这些点初始位置不是 0。</blockquote>
    </article>
  </body>
</html>
